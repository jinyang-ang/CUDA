/* Start Header *****************************************************************/

/*! \file kirsch.comp

    \author Ang Jin Yang, jinyang.ang 2000940

    \par email : jinyang.ang.digipen.edu

    \date 15/3/2024

    \brief Copyright (C) 2024 DigiPen Institute of Technology.

Reproduction or disclosure of this file or its contents without
the prior written consent of DigiPen Institute of Technology is prohibited. */

/* End Header *******************************************************************/


#version 450

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform readonly image2D inputImage;
layout (binding = 1, rgba8) uniform image2D resultImage;

const    float kirsch[8][3][3] = {
        {
         {5, 5, 5},
         {-3, 0, -3},           /*rotation 1 */
         {-3, -3, -3}
         },
        {
         {5, 5, -3},
         {5, 0, -3},            /*rotation 2 */
         {-3, -3, -3}
         },
        {
         {5, -3, -3},
         {5, 0, -3},            /*rotation 3 */
         {5, -3, -3}
         },
        {
         {-3, -3, -3},
         {5, 0, -3},            /*rotation 4 */
         {5, 5, -3}
         },
        {
         {-3, -3, -3},
         {-3, 0, -3},           /*rotation 5 */
         {5, 5, 5}
         },
        {
         {-3, -3, -3},
         {-3, 0, 5},            /*rotation 6 */
         {-3, 5, 5}
         },
        {
         {-3, -3, 5},
         {-3, 0, 5},            /*rotation 7 */
         {-3, -3, 5}
         },
        {
         {-3, 5, 5},
         {-3, 0, 5},            /*rotation 8 */
         {-3, -3, -3}
         }
    };

//two extra row/col
shared vec3 sData[16+2][16+2];

void main()
{
    for (int i = 0; i < 2; ++i) 
    {
        // Calculate linear thread index
        uint linearIdx = (i * 256) + gl_LocalInvocationID.y * 16 + gl_LocalInvocationID.x;

        // Calculate 2D indices for accessing shared memory
        uint sharedCoordsX = linearIdx % 18;
        uint sharedCoordsY = linearIdx / 18;

        // Calculate global coordinates for loading data
        ivec2 globalCoord = ivec2(gl_WorkGroupID.x * 16 + sharedCoordsX - 1, gl_WorkGroupID.y * 16 + sharedCoordsY - 1);

        // Load data into shared memory
        if (globalCoord.x >= 0 && globalCoord.x < imageSize(inputImage).x && globalCoord.y >= 0 && globalCoord.y < imageSize(inputImage).y) {
            sData[sharedCoordsY][sharedCoordsX] = imageLoad(inputImage, globalCoord).rgb;
        }
        else {
            // If outside image bounds, fill with zeros
            sData[sharedCoordsY][sharedCoordsX] = vec3(0.0);
        }
    }
    barrier(); // Ensure all threads have loaded their data before proceeding
    
   // Apply Kirsch operator
    vec3 max_sum = vec3(0.0);
    for (int i = 0; i < 8; ++i) {
        vec3 sum = vec3(0.0);
        for (int j = -1; j <= 1; ++j) {
            for (int k = -1; k <= 1; ++k) {
                sum += kirsch[i][j + 1][k + 1] * sData[gl_LocalInvocationID.y + 1 + j][gl_LocalInvocationID.x + 1 + k];
            }
        }
        max_sum = max(max_sum, sum);
    }

   // Write result to output image
    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(clamp(max_sum / 8, 0.0, 1.0), 1.0));
}