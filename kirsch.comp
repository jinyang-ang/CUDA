#version 450

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform readonly image2D inputImage;
layout (binding = 1, rgba8) uniform image2D resultImage;

const    float kirsch[8][3][3] = {
        {
         {5, 5, 5},
         {-3, 0, -3},           /*rotation 1 */
         {-3, -3, -3}
         },
        {
         {5, 5, -3},
         {5, 0, -3},            /*rotation 2 */
         {-3, -3, -3}
         },
        {
         {5, -3, -3},
         {5, 0, -3},            /*rotation 3 */
         {5, -3, -3}
         },
        {
         {-3, -3, -3},
         {5, 0, -3},            /*rotation 4 */
         {5, 5, -3}
         },
        {
         {-3, -3, -3},
         {-3, 0, -3},           /*rotation 5 */
         {5, 5, 5}
         },
        {
         {-3, -3, -3},
         {-3, 0, 5},            /*rotation 6 */
         {-3, 5, 5}
         },
        {
         {-3, -3, 5},
         {-3, 0, 5},            /*rotation 7 */
         {-3, -3, 5}
         },
        {
         {-3, 5, 5},
         {-3, 0, 5},            /*rotation 8 */
         {-3, -3, -3}
         }
    };

//two extra row/col
shared vec3 sData[16+2][16+2];

void main()
{
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    
    // Load input image data into shared memory with appropriate border handling
    for (int i = -1; i <= 1; ++i) {
        for (int j = -1; j <= 1; ++j) {
            ivec2 neighborCoords = pixelCoords + ivec2(i, j);
            sData[gl_LocalInvocationID.x + i + 1][gl_LocalInvocationID.y + j + 1] = imageLoad(inputImage, neighborCoords).rgb;
        }
    }

    barrier(); // Ensure all threads have loaded their data before proceeding
    
    // Apply Kirsch operator
    vec3 result = vec3(0.0);
    for (int i = 0; i < 8; ++i) {
        float sum = 0.0;
        for (int j = -1; j <= 1; ++j) {
            for (int k = -1; k <= 1; ++k) {
                sum += kirsch[i][j + 1][k + 1] * sData[gl_LocalInvocationID.x + 1 + j][gl_LocalInvocationID.y + 1 + k][0];
            }
        }
        result[i] = sum;
    }

    // Clamp result to ensure it's within valid range
    result = clamp(result, 0.0, 1.0);
    //vec3 resultColor = vec3(clamp(result / 8.0, 0.0, 1.0));

    // Write result to output image
    imageStore(resultImage, pixelCoords, vec4(result, 1.0));
}
